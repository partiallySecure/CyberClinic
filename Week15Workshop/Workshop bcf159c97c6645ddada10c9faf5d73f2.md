# Workshop

## Getting the bits:

- Navigate to SPG in on the HTB website
- Download the files

![image.png](image.png)

- Unzip the folder with the password ‘hackthebox’
- You will see two files. ‘output.txt’ file and ‘source.py’ python script

![image.png](image%201.png)

![image.png](image%202.png)

## What does this mean for the trout population?

![image.png](image%203.png)

- sha256 hashing is imported from hashlib for secure transmission of the files
- The ‘random’ library is imported for proper generation of random numbers
- ‘Master_key’ and ‘flag’ are imported from an unknown area of memory
- AES encryption is imported from crypto cipher
- Other encoding processes are also brought in. Not really sure of their purpose tho tbh

![image.png](image%204.png)

ALPHABET is a variable containing concatenating  all ascii letters, all digits represented as a string and the string “~!@$%^&*”

![image.png](image%205.png)

- Creates a function called ‘generate_password’
- Creates the variable ‘master_key’ by taking the little-endian (reversed) order of bits from the binary number contained in the constant ‘MASTER_KEY’ and stores it as an integer
- Defines the variable password as an empty string
- While loop prepares to cycle through each bit in the master key
- ‘bit’ is a boolean that checks if the least significant bit of each integer of the master key is 1 using a bitwise &
- if:
    - If the least significant bit is a 1 a random character from the first half of the ALPHAHBET string (abcdefghijklmnopqrstuvwxyzABCDEFGHI) is added to the password.
- else:
    - A random character from the second half of the ALPHABET (JKLMNOPQRSTUVWXYZ123456789~!@$%^&*) is added instead.
- The master_key is shifted to the right >>

![image.png](image%206.png)

- A password is created using the function we went through
- computes the SHA-256 hash of MASTER_KEY producing a 32-byte encryption key. This key will be used for AES encryption.
- Uses the AES encryption algorithm in ECB (Electronic Codebook) mode. AES.MODE_ECB means the data is split into 16-byte blocks, and each block is encrypted independently.
- ‘(pad(FLAG, 16)) ensures FLAG is a multiple of 16 bytes (required for AES). The padded FLAG is encrypted using the AES cipher.
- Writes two lines to the output.txt file
    - Your password [password generated with the function]
    - Encrypted flag (base64 encoded FLAG ciphered in pad 16 AES encryption using a sha256 hash of MASTER_KEY as the encryption key)

## Taking Back What’s Rightfully Mine

![image.png](image%207.png)

- Much of the same imports as the problem code, but using the ‘unpad’ and ‘decode’ variants of the cryptography appliances and base64 algorithms to undo the functions.

![image.png](image%208.png)

- ALPHABET stays the same.

![image.png](image%209.png)

- The loudOutput function is declared
- Opens the output.txt file from the same location in memory 
(The ‘with’ operator makes sure the block closes after the block exits)
- ‘password’ is initiated and assigned as the section of text following the ‘ : ‘
- ‘flag’ is initiated and assigned as the b64 decoded second section of text following the ‘ : ‘ on the second line
- the function then returns the ‘password’ and ‘flag’ variables

![image.png](image%2010.png)

- The function giveMaster is created, accepting the password variable
- The first and second halves of the ALPHABET are assigned to independent variables
- A list is initiated called ‘bits’
- For each character in the password:
    - If the character is from the first half of the ALPHABET, add a 1 to the ‘bits’ list
    - Otherwise add a 0
- After It has iterated through every character the master key binary is created by reversing the order of the bits to make the binary ‘big endian’ again.
- The Function returns the binary key

![image.png](image%2011.png)

- decryptData is initiated as a function, accepting the ‘masterKeyBinary’ and ‘flag’ as inputs
- The key needs to be used to decrypt the sha hash and thus needs to be in hexadecimal. long_to_bytes is a pre-built function that does that automatically the 2 is there to prepare the function for a base 2 number. It is also reversed again to put the final key into ‘little-endian’ for decryption but this is an oversight on my part
- The hex number is then turned into an AES decryption key
- The cipher block is then created as a collection of blocks consisting of 16-bytes to be used by the inbuild decrypt() function
- the decryptedFlag is then generated by decrypting the cipher in Electronic Code Block mode

ECB mode is insecure because each 16 byte block is encoded with the same algorithm meaning patterns can be visible

![image.png](image%2012.png)

- The main function!
- password and flag are calculated by the loadOutput() function
- masterKeyBinary is generated from the giveMaster() function applied to the password
- FLAG is created by applying the masterKeyBinary and flag to the decrypt data() function
- A text file called Done.txt is created written to
    - FLAG is decoded from bytes to uft-8 plaintext characters and written to the file
- The print was just there for testing purposes
- If the name of the document is the same as it is saved as the program will execute the main() function because main() is not executed automatically in python as it is in other languages.

## OH NO MR SQUIDWARD, ME CODES!!

 

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha256
from Crypto.Util.number import long_to_bytes
import string
from base64 import b64decode

ALPHABET = string.ascii_letters + string.digits + '~!@#$%^&*'

def loadOutput():
    with open('output.txt') as f:
        password = f.readline().split(' : ')[1]
        flag = b64decode(f.readline().split(' : ')[1])
        
    return password, flag
    
def giveMaster(password):
    firstHalf = ALPHABET[:len(ALPHABET)//2]
    secondHalf = ALPHABET[len(ALPHABET)//2:]
    bits = []
    for char in password:
        if char in firstHalf:
            bits.append('1')
        else:
            bits.append('0')
    masterKeyBinary = ''.join(bits[::-1])
    
    return masterKeyBinary
    
def decryptData(masterKeyBinary, flag):
    keyBytes = long_to_bytes(int(masterKeyBinary, 2))[::-1]
    aesKey = sha256(keyBytes).digest()
    cipher = AES.new(aesKey, AES.MODE_ECB)
    decryptedFlag = cipher.decrypt(flag)
    
    return decryptedFlag
    
def main():
    password, flag = loadOutput()
    masterKeyBinary = giveMaster(password)
    FLAG = decryptData(masterKeyBinary, flag)
    with open('Done.txt', 'w') as f:
        f.write(FLAG.decode(errors="ignore"))
        
    print(password, flag, FLAG, masterKeyBinary)

if __name__ == "__main__":
    main()
```